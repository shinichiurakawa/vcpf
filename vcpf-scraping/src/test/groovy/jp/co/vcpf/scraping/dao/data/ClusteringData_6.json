{"title":"SpringBoot??????docker????","link":"https://qiita.com/wataling/items/fa8b74fa50d80b88aea3","content":"Qiita Community SignupLogin Java MySQL docker SpringBoot 11 @wataling SpringBootの開発環境をdockerでつくる JavaMySQLdockerSpringBoot 11 はじめに 趣味の開発でチームでSpringBootを使ってwebサービスを作ろうという話になった。javaはわかるがSpringBootの知識は0なのでdockerを使って試しにREST APIを作ってみた。 作成するにあたって、以下の記事を参考にしました。 Spring Boot with Docker な開発環境を考える Spring Boot の Docker コンテナと MySQL の Docker コンテナの接続 開発環境は以下の通り OS: macOS High Sierra docker: 17.12.0-ce docker-compose version 1.18.0 今回の記事のソースはこちら Github watariGIT/boot-get-started 作るもの DBコンテナは既存のMySQLのimageを用いる APPコンテナはDockerFileを作成しファイルをマウントすることで、ビルドする度に新たにimageを作成する必要を無くす MyadminコンテナはMySQL簡易操作用 SpringBootの構築 SpringBootわけわからんおじさんなので、準備としてローカルでRestApiを作ります DBの準備 mysqlのコンテナに必要なデータを入れて立ち上げとく。これをしないとテストも通らない為ビルドができない。 コンテナ起動時に必要なことは以下の通り 事前にsqlファイルを作り/docker-entrypoint-initdb.dにマウントすると起動時に実行してくれるのでマウントさせる。 SpringBoot用のmysqlユーザ sbootを作成する localhostのポート3306にリンクさせる これらを加味すると以下のようなコマンドになる docker container run -v $(PWD)/sql:/docker-entrypoint-initdb.d -d -e MYSQL_DATABASE=mydb -e MYSQL_USER=sboot -e MYSQL_PASSWORD=sboot -e MYSQL_ROOT_PASSWORD=root-pass -p 3306:3306 -d mysql 長くはなるが、docker-composeを作るまでの我慢しよう。 build.gradleの作成 SpringBootはビルド、ライブラリ管理にgradleを使っているそうです。 SPRING INITIALIZRに必要事項を記入し雛形を落としましょう。 ディレクトリトップにあるbuild.gradleファイルを以下のように編集します。 buildscript {\n    ext {\n        springBootVersion = '1.5.2.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n\napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'org.springframework.boot'\n\njar {\n    baseName = 'boot-get-started'\n    version = '0.0.1-SNAPSHOT'\n}\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\n\ndependencies {\n    compile('org.springframework.boot:spring-boot-starter-web')\n    compile(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n    compile(\"org.springframework.boot:spring-boot-starter-data-rest\")\n    compile('mysql:mysql-connector-java:6.0.6')\n    compileOnly('org.projectlombok:lombok')\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n}\n dependenciesのとこに必要なライブラリを記入すれば良いらしい便利。 testCompileのとこで多分テストもしてくれてるうれしい。 ここらへんもあとで詳しく学びたい。 gradlew clean buildでライブラリのインストールが完了します。 Entity,Repositoryの作成 DBにたいおうするEnttityとRepositoryをsrc/main/java/com/exampleに作成する。 ここら辺は参考記事をコピっただけなのであまり理解はしていない。 今回は環境構築がメインなので割り切る。 application.ymlの作成 src/main/resources/application.ymlを作成する。 ここにDBの接続先を記入する。 アプリケーションをローカルで実行する場合と、コンテナ上で接続する場合とでは接続先が変わることに注意する。 spring:\n  profiles:\n    active: localhost\n---\nspring:\n  profiles: localhost\n  datasource:\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mydb\n    username: sboot\n    password: sboot\n  jpa:\n    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect\n    show-sql: true\n    hibernate:\n      ddl-auto: update\n  data:\n    rest:\n      base-path: /api\n\n---\nspring:\n  profiles: docker\n  datasource:\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://dbserver/mydb\n    username: sboot\n    password: sboot\n  jpa:\n    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect\n    show-sql: true\n    hibernate:\n      ddl-auto: update\n  data:\n    rest:\n      base-path: /api\n localhost、dockerに対応するプロファイルを作りlocalhostをデフォルトにする。 プロファイルの切り替えはDockerFile内で行う(後述) ビルド mysqlコンテナを立てた状態でgradlew buildをして、BUILD SUCCESSFULが出ればOK。 ビルドがうまくいったので次はアプリケーションをコンテナ化し実行できるようにする。 DockerFile、Composeの作成 最初にアプリケーションのDockerFileを作成する。 # use alpine as base image\nFROM ubuntu:16.04\n\nRUN apt-get update\nRUN apt-get -y install openjdk-8-jdk\nENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64\n\n# recommended by spring boot\nVOLUME /tmp\n\n# create directory for application\nRUN mkdir /app\nWORKDIR /app\n\n# jar target\nENV JAR_TARGET \"boot-get-started-0.0.1-SNAPSHOT.jar\"\n\n# set entrypoint to execute spring boot application\nENTRYPOINT [\"sh\",\"-c\",\"java -jar -Dspring.profiles.active=docker build/libs/${JAR_TARGET}\"]\n ENTRYPOINTの-Dspring.profiles.active=dockerでapplication.ymlに記載したプロファイルに切り替える。 実行時にビルドしたファイルを/appにマウントする。 JAR_TARGETに指定したファイルを実行する。(デフォルトでは\"boot-get-started-0.0.1-SNAPSHOT.jar\") 次にdb,app,phpmyadminコンテナを組み合わせたdocker-compose.ymlを記載する version: '2'\nservices:\n\n    dbserver:\n        image: mysql\n        volumes:\n            - ./sql:/docker-entrypoint-initdb.d\n            - mysql-db:/var/lib/mysql\n        environment:\n            MYSQL_DATABASE: mydb\n            MYSQL_USER: sboot\n            MYSQL_PASSWORD: sboot\n            MYSQL_ROOT_PASSWORD: root\n\n    app:\n        build: .\n        image: watari/boot:0.1.0                            \n        depends_on:\n            - dbserver\n        ports:\n            - \"8080:8080\"\n        volumes:\n            - .:/app\n        environment:\n            JAR_TARGET: boot-get-started-0.0.1-SNAPSHOT.jar\n\n    myadmin:\n        image: phpmyadmin/phpmyadmin\n        depends_on:\n            - dbserver\n        environment:\n            PMA_ARBITRARY: 1\n            PMA_HOST: dbserver\n            PMA_USER: root\n            PMA_PASSWORD: root\n        ports:\n            - \"1111:80\"\n\nvolumes:\n    mysql-db:\n        driver: local\n 実行 docker-compose upで実行できる。初回はDockerファイルからイメージを作成する必要があるので--buildオプションをつけると良い。 コンテナを立ち上げ実行ができたら　curlコマンドで確認する。 $ curl http://localhost:8080/api/users\n{\n  \"_embedded\" : {\n    \"users\" : [ {\n      \"firstName\" : \"Taro\",\n      \"lastName\" : \"Yamada\",\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/api/users/1\"\n        },\n        \"user\" : {\n          \"href\" : \"http://localhost:8080/api/users/1\"\n        }\n      }\n    }, {\n      \"firstName\" : \"Hanako\",\n      \"lastName\" : \"Tanaka\",\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/api/users/2\"\n        },\n        \"user\" : {\n          \"href\" : \"http://localhost:8080/api/users/2\"\n        }\n      }\n    } ]\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/api/users\"\n    },\n    \"profile\" : {\n      \"href\" : \"http://localhost:8080/api/profile/users\"\n    }\n  }\n}\n おわりに SpringBootの知識はないまんだがコンテナを使うことで簡単に環境構築することができた。 けど、buildをローカルでやってるのでなんだかなという感じ、buildもコンテナにやらせた方が良いのでは？とも考えている。 それと今はemacsベースで開発してるけど、今後eclipseなどの統合開発環境で開発するときにはうまく組み合わせる必要があるなってかんじです(ここらへんのノウハウもない)。 これをたたき台に試行錯誤していこうかなと思います。 Edit request Stock Like11 wataling Sier =>　退職院進 =>　アドテクの会社 はじめに 作るもの SpringBootの構築 DBの準備 build.gradleの作成 Entity,Repositoryの作成 application.ymlの作成 ビルド DockerFile、Composeの作成 実行 おわりに © 2011-2018 Increments Inc. Terms Privacy Help Contact About Users Tags Items Blog API Qiita:Team"}