{"title":"Spring Data REST?MySQL?????","link":"https://qiita.com/quwahara/items/4bfc3da62bd3a6c94e2a","content":"Qiita Community SignupLogin Java MySQL spring-boot spring-data-jpa spring-data-rest 16 @quwahara Spring Data RESTでMySQLにアクセス JavaMySQLspring-bootspring-data-jpaspring-data-rest 16 More than 1 year has passed since last update. はじめに Spring Data RESTを使って、MySQLにアクセスする最も簡単なREST APIを作成します。 参考 Accessing JPA Data with REST https://spring.io/guides/gs/accessing-data-rest/ 前提条件 下の記事の後の状態を前提にしています Spring BootとAngularUI UI-Routerを使ってみる MySQLを利用できること 環境 JVM: 1.8.0_45 (Oracle Corporation 25.45-b02) OS: Mac OS X 10.11.3 x86_64 MySQL: Server version: 5.5.28 Source distribution Spring Tool Suite Version: 3.7.3.RELEASE Build Id: 201602250940 Platform: Eclipse Mars.2 (4.5.2) (こちらから入れました https://spring.io/tools/sts/all) Buildship: Eclipse Plug-ins for Gradle 1.0.13.v20160411-1723 (Help -> Eclipse marketplaceから入れました) 手順 依存するLibraryを追加する Spring Data JPA、Spring Data REST、MySQL Connector/Jを使えるように、ビルドスクリプトの依存物として、// Addを追記します。 build.gradle dependencies {\n    compile 'org.webjars:jquery:2.2.3'\n    compile 'org.webjars:angularjs:1.5.3'\n    compile 'org.webjars:angular-ui-router:0.2.18'\n    compile 'org.webjars:bootstrap:3.3.6'\n\n    // Add\n    compile('org.springframework.boot:spring-boot-starter-data-jpa')\n    // Add\n    compile('org.springframework.boot:spring-boot-starter-data-rest')\n    compile('org.springframework.boot:spring-boot-starter-web')\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n\n    // Add\n    compile('mysql:mysql-connector-java')\n}\n 追記を反映するために、Package ExplorerでSSP37(プロジェクトルート)を選び右クリック、 Gradle -> Refresh Gradle Project をクリックします。 Package ExplorerのProject and External Dependenciesに、追記したJarあるか確認します。 参考 Spring IO Platform Reference Guide Appendix A. Dependency versions http://docs.spring.io/platform/docs/2.0.3.RELEASE/reference/htmlsingle/#appendix WebJars http://www.webjars.org/ 設定する JPAやMySQLを使うのに、必要最小限と思われる設定をします。 src/main/resources/application.properties spring.data.rest.basePath=/api\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=user\nspring.datasource.password=password\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database=MYSQL\nspring.jpa.hibernate.ddl-auto=update\n spring.data.rest.basePath REST APIのルートの設定です。変えたほうが分かり易いと思い変えました。 参考 Spring Data REST - Reference Documentation 4.6.1. Changing the base URI http://docs.spring.io/spring-data/rest/docs/2.4.4.RELEASE/reference/html/#getting-started.basic-settings spring.datasource.* MySQLへの接続文字列です。ご自分の環境に合わせて値を指定して下さい。 hibernateが自動で、テーブルの作成や項目の変更、破棄をしてくれたりするので、それらが行える権限を持つ、MySQLのユーザーを指定して下さい。 参考 Spring Boot Reference Guide 29.1.2 Connection to a production database https://docs.spring.io/spring-boot/docs/1.3.3.RELEASE/reference/htmlsingle/#boot-features-connect-to-production-database spring.jpa.database=MYSQL 自動で生成されるSQLやDDLが、MySQL向けになるように指示します。 spring.jpa.hibernate.ddl-auto=update Entityになるクラスを作ると、自動でテーブルの作成、項目変更をしてくれるようにします。 参考 Spring Boot Reference Guide 73.5 Configure JPA properties https://docs.spring.io/spring-boot/docs/1.3.3.RELEASE/reference/htmlsingle/#howto-configure-jpa-properties Hibernate Reference Documentation 3.4. Optional configuration properties Table 3.7. Miscellaneous Properties hibernate.hbm2ddl.auto Automatically validates or exports schema DDL to the database when the SessionFactory is created. With create-drop, the database schema will be dropped when the SessionFactory is closed explicitly. e.g. validate | update | create | create-drop http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html_single/#configuration-optional Entityを作る 簡単なEntityを作ってみます。 綴り(spelling)と好みか(favorite)を項目に持つ、単語(word)というEntityを作ってみました。 src/main/java/com/example/domain/Word.java package com.example.domain;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\n@Entity\npublic class Word {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(nullable = false)\n    private String spelling;\n\n    @Column(nullable = false)\n    private Boolean favorite;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getSpelling() {\n        return spelling;\n    }\n\n    public void setSpelling(String spelling) {\n        this.spelling = spelling;\n    }\n\n    public Boolean getFavorite() {\n        return favorite;\n    }\n\n    public void setFavorite(Boolean favorite) {\n        this.favorite = favorite;\n    }\n}\n Repositoryを作る 先ほどのWordを操作するRepositoryを作ります。 Spring Data RESTは、このようなRepositoryを作ると、そのEntityをCRUD操作できるAPIを自動で公開してくれます。 src/main/java/com/example/domain/WordRepository.java package com.example.domain;\n\nimport java.util.List;\n\nimport org.springframework.data.repository.PagingAndSortingRepository;\nimport org.springframework.data.repository.query.Param;\n\npublic interface WordRepository extends PagingAndSortingRepository<Word, Long> {\n\n    List<Word> findBySpellingLikeOrderBySpellingAsc(@Param(\"spelling\") String spelling);\n\n}\n APIを使ってみる それではcURLで、APIを使ってみましょう。 まずはWebアプリケーションを起動します。 Spring Data RESTが公開するAPIのPathは、設定したAPIのルートと、Repositoryを作ったEntityの名前を小文字にして、複数形のsを付け、連結したものになります。 今回は、APIのルートを/apiに設定し、EntityのWordはwordsになるので、Path名は/api/wordsとなります。 そのPathにcurlでアクセスします。 $ curl http://localhost:8080/api/words\n 下のような応答がありました。 {\n  \"_embedded\" : {\n    \"words\" : [ ]\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/api/words\"\n    },\n    \"profile\" : {\n      \"href\" : \"http://localhost:8080/api/profile/words\"\n    },\n    \"search\" : {\n      \"href\" : \"http://localhost:8080/api/words/search\"\n    }\n  },\n  \"page\" : {\n    \"size\" : 20,\n    \"totalElements\" : 0,\n    \"totalPages\" : 0,\n    \"number\" : 0\n  }\n}\n とりあえずレコードを一件登録してみます。 -dで指定するJSON部分に、idを除くEntityの全ての項目を指定し、先ほどのPathへPOSTすると登録できます。 $ curl -X POST -H \"Content-Type:application/json\" -d '{ \"spelling\": \"APPLE\", \"favorite\": true }' http://localhost:8080/api/words\n id=13で登録できたようです。13は環境によって変わるので読み替えて下さい。 {\n  \"spelling\" : \"APPLE\",\n  \"favorite\" : true,\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/api/words/13\"\n    },\n    \"word\" : {\n      \"href\" : \"http://localhost:8080/api/words/13\"\n    }\n  }\n}\n もう一度そのレコードを取得してみましょう。 Pathにidを連結すると、そのレコードにアクセスできます。 $ curl http://localhost:8080/api/words/13\n {\n  \"spelling\" : \"APPLE\",\n  \"favorite\" : true,\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/api/words/13\"\n    },\n    \"word\" : {\n      \"href\" : \"http://localhost:8080/api/words/13\"\n    }\n  }\n}\n レコードを更新してみます。 -dで指定するJSON部分に、idを除くEntityの全ての項目を指定し、idを指定したPathへPUTすると更新できます。 下ではAPPLEからappleへ更新しました。 $ curl -X PUT -H \"Content-Type:application/json\" -d '{ \"spelling\": \"apple\", \"favorite\": false }' http://localhost:8080/api/words/13\n{\n  \"spelling\" : \"apple\",\n  \"favorite\" : false,\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/api/words/13\"\n    },\n    \"word\" : {\n      \"href\" : \"http://localhost:8080/api/words/13\"\n    }\n  }\n}\n レコードを削除してみます。 idを連結したPathへDELETEすると、削除できます。 $ curl -X DELETE http://localhost:8080/api/words/13\n 検索してみます。 とりあえず検索するために、レコードを3件登録します。 curl -X POST -H \"Content-Type:application/json\" -d '{ \"spelling\": \"apple\", \"favorite\": true }' http://localhost:8080/api/words\ncurl -X POST -H \"Content-Type:application/json\" -d '{ \"spelling\": \"apricot\", \"favorite\": true }' http://localhost:8080/api/words\ncurl -X POST -H \"Content-Type:application/json\" -d '{ \"spelling\": \"pineapple\", \"favorite\": false }' http://localhost:8080/api/words\n 検索してみます。 検索のPathはsearchにRepositoryのメソッド名を連結します。 検索キーは、クエリ文字列に連結します。 SQLのLike条件のワイルドカード文字に当たる%は%25にエンコードして指定します。 これでappleで終わるspellingのレコードを検索しています。 $ curl http://localhost:8080/api/words/search/findBySpellingLikeOrderBySpellingAsc?spelling=%25apple\n{\n  \"_embedded\" : {\n    \"words\" : [ {\n      \"spelling\" : \"apple\",\n      \"favorite\" : true,\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/api/words/14\"\n        },\n        \"word\" : {\n          \"href\" : \"http://localhost:8080/api/words/14\"\n        }\n      }\n    }, {\n      \"spelling\" : \"pineapple\",\n      \"favorite\" : false,\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/api/words/16\"\n        },\n        \"word\" : {\n          \"href\" : \"http://localhost:8080/api/words/16\"\n        }\n      }\n    } ]\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/api/words/search/findBySpellingLikeOrderBySpellingAsc?spelling=%25apple\"\n    }\n  }\n}\n 参考 Sample Repository https://github.com/quwahara/SSP37/tree/600-rest Edit request Stock Like16 光昭 桑原quwahara Twitter is @quwahara はじめに 参考 前提条件 環境 Spring Tool Suite 手順 依存するLibraryを追加する 参考 設定する spring.data.rest.basePath 参考 spring.datasource.* 参考 spring.jpa.database=MYSQL spring.jpa.hibernate.ddl-auto=update 参考 Entityを作る Repositoryを作る APIを使ってみる とりあえずレコードを一件登録してみます。 レコードを更新してみます。 レコードを削除してみます。 検索してみます。 参考 © 2011-2018 Increments Inc. Terms Privacy Help Contact About Users Tags Items Blog API Qiita:Team"}